import { TinyPgError } from 'tinypg';
import { UnauthorizedError } from 'express-jwt';
import { errorHandler } from '../errorHandler';
import { DatabaseError } from '../../errors';
import { getMockRequest, getMockResponse } from '../../test/mockExpress';
import { getMockNextFunction } from '../../test/utils';

describe('errorHandler', () => {
	it('should process errors that are not Errors', () => {
		const err = 42;
		const req = getMockRequest();
		const res = getMockResponse();
		const statusMock = jest.fn().mockReturnValue(res);
		const contentTypeMock = jest.fn().mockReturnValue(res);
		const sendMock = jest.fn().mockReturnValue(res);
		res.status = statusMock;
		res.contentType = contentTypeMock;
		res.send = sendMock;
		const next = getMockNextFunction();
		errorHandler(err, req, res, next);
		expect(statusMock).toHaveBeenCalledWith(500);
		expect(sendMock).toHaveBeenCalledWith(
			expect.objectContaining({
				name: 'UnknownError',
				message: 'Unknown error.',
				details: [err],
			}),
		);
	});

	it('should send 401 for an UnauthorizedError generated by express-jwt', () => {
		const err = new UnauthorizedError('invalid_token', new Error());
		const req = getMockRequest();
		const res = getMockResponse();
		const statusMock = jest.fn().mockReturnValue(res);
		const contentTypeMock = jest.fn().mockReturnValue(res);
		const sendMock = jest.fn().mockReturnValue(res);
		res.status = statusMock;
		res.contentType = contentTypeMock;
		res.send = sendMock;
		const next = getMockNextFunction();
		errorHandler(err, req, res, next);
		expect(statusMock).toHaveBeenCalledWith(401);
		expect(sendMock).toHaveBeenCalledWith(
			expect.objectContaining({
				name: 'UnauthorizedError',
				message: '',
				details: [err],
			}),
		);
	});

	it('should send 503 on JWKS rate limit error', () => {
		const err = 'Requested tokens 1 exceeds maximum tokens per interval 0';
		const req = getMockRequest();
		const res = getMockResponse();
		const statusMock = jest.fn().mockReturnValue(res);
		const contentTypeMock = jest.fn().mockReturnValue(res);
		const sendMock = jest.fn().mockReturnValue(res);
		res.status = statusMock;
		res.contentType = contentTypeMock;
		res.send = sendMock;
		const next = getMockNextFunction();
		errorHandler(err, req, res, next);
		expect(statusMock).toHaveBeenCalledWith(503);
		expect(sendMock).toHaveBeenCalledWith(
			expect.objectContaining({
				name: 'UnknownError',
				message: 'Unknown error.',
				details: [err],
			}),
		);
	});

	it('should process Database Errors with unknown status codes', () => {
		const err = new DatabaseError(
			'A database error',
			new TinyPgError('something unknown', undefined, {
				error: {
					code: 'some unexpected code',
				},
			}),
		);
		const req = getMockRequest();
		const res = getMockResponse();
		const statusMock = jest.fn().mockReturnValue(res);
		const contentTypeMock = jest.fn().mockReturnValue(res);
		const sendMock = jest.fn().mockReturnValue(res);
		res.status = statusMock;
		res.contentType = contentTypeMock;
		res.send = sendMock;
		const next = getMockNextFunction();
		errorHandler(err, req, res, next);
		expect(statusMock).toHaveBeenCalledWith(500);
		expect(sendMock).toHaveBeenCalledWith(
			expect.objectContaining({
				name: 'DatabaseError',
				message: 'Unexpected database error.',
				details: [
					{
						code: 'some unexpected code',
					},
				],
			}),
		);
	});
});
